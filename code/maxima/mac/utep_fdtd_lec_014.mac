/* [wxMaxima: comment start ]
UTEP EMPossible - EM Analysis Using FDTD

Lecture 14 - 3D Update Equations With PML

Review Of Lecture 13

Tensors

Matrix/Operator - Scales and Changes Orientation Of a Vector
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
load(vect);load(eigen);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
V:[V_x, V_y, V_z];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Multiply Vector By Scalar - Orientation Constant
Magnitude of V will be scaled larger or smaller
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
S * V;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
A Tensor - 3x3 Matrix
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
M:matrix([M_11, M_12, M_13],[M21,M_22,M_23],[M_31,M_32, M33]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Multiplication Of Tensor With Vector
Orientation May Change
3 rows x 3 columns
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
M * V;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Dot Product Of Tensor With Vector 
3 rows x 1 column
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
M . V;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Reflectance From Lossy Surface - Air ⟶ Glass 

N = Complex Refractive Index
n = Ordinary Refractive Index (Real)
κ = extinction coefficient (Imaginary ⟶ Decay)
** Loss contributes to reflections not transmission
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
N = n + j *κ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
R = ((1-n)^2 + κ^2)/((1+n)^2 + κ^2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Fresnel Equations - Reflection, Transmission and Refraction At An Interface

Isotropic Case
θ_inc = θ_ref = θ_1
Snell's Law : n_1 * sin(θ_1) = n_2 *sin(θ_2)

TE Mode ⟶ E Vector ⟂ Plane Of Incidence
                    E Vector May Be Parallel To Interface

TE Wave Polarization (Transverse Magnetic) 

η_1 = impedence of material 1 (e.g. air)
η_2 = impedence of material 2 (e.g. glass)

n_1 = refractive index of material 1
n_2 = refractive index of material 2

θ_1 = angle of incidence of incoming wave = angle of reflection in material 1
θ_2 = angle of refraction of transmitted wave in material 2 (n_1 < n_2 for air⟶glass)
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
r_TE:(η_2 * cos(θ_1) - η_1 * cos(θ_2))/(η_2*cos(θ_1) + η_1*cos(θ_2));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
t_TE: ( 2 * η_2 * cos(θ_1) )/(η_2*cos(θ_1) + η_1*cos(θ_2));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
TE Mode ⟶ H ⟂ k_inc and H ⟂ k_ref and H ⟂ k_trn
                     H ∥ Plane Of Incidence
                     H never parallel to interface

k_inc = wave vector k for incident wave
k_ref = wave vector k for reflected wave
k_trn = wave vector k for transmitted wave

NOTE: THE DIFFERENCE IN MATERIAL IMPEDENCE AT THE INTERFACE CAUSES:
    THE CHANGE IN WAVE VELOCITY AT THE INTERFACE AND IN MATERIAL #2
    WAVE REFLECTION BACK INTO MATERIAL #1 FROM THE INTERFACE
    CHANGE OF DIRECTION WITH TRANSMISSION ACROSS INTERFACE INTO MATERIAL #2
    THE IMPEDENCE CHANGE DISRUPTS AND DISTORTS THE E AND H FIELDS 
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
Maxwell's Curl Equations IN Anisotropic Media
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
E:[E_x, E_y, E_z]; H:[H_x,H_y, H_z];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
PML Material is Anisotropic
Relative Permeability μ_r and Relative Permittivity ε_r  become tensors
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
ε_r:matrix([ε_xx, ε_xy, ε_xz], [ε_yx, ε_yy, ε_yz],[ε_zx, ε_zy, ε_zz]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
μ_r:matrix([μ_xx, μ_xy, μ_xz], [μ_yx, μ_yy, μ_yz],[μ_zx, μ_zy, μ_zz]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
faraday:express(curl(H) = %i*ω*ε_0 * ε_r  * E);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ampere:express(curl(E)) = %i*ω*μ_0 * μ_r  * E;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
M_curl:matrix([0, -Dz, Dy],[ Dz, 0, -Dx],[-Dy, Dx,0]) ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
simp:false;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Maxima doesn't natively allow partial application of the diff() function
This section is for pedagogical purposes
Showing Explicit Tensor-Vector Equations 
D_z ⟶ ∂/∂z
D_y ⟶ ∂/∂y
D_x ⟶ ∂/∂x
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
M_faraday:M_curl * transpose(H) = %i * ω*ε_0* ε_r* transpose(E);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
M_ampere:M_curl * transpose(E) = %i * ω*μ_0* μ_r*transpose(H);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
simp:true;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Isotropic Material Tensor
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
perm_iso:matrix([ε_iso, 0,0],[0,ε_iso,0],[0,0,ε_iso]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Uniaxial Anisotropy
ord = ordinary wave
ext = extraordinary wave
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
perm_uniaxial_aniso:matrix([ ε_ord, 0,0],[0,ε_ord,0],[0,0,ε_ext]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Biaxial Anisotropy
3 different permittivity values on diagonal
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
perm_biaxial_aniso:matrix([ ε_a, 0,0],[0,ε_b,0],[0,0,ε_c]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Incorporating Loss Into Maxwell's Equations

Two ways to incorporate loss:
    At low frequencies and/or for time domain the (ε_r,σ) system is used
    ∇xH = J + j*ω*D = σ*E + j*ω*E = (σ + j*ω*ε_r_norm)*E {Used for FDTD}

    At high frequencies and in the frequency domain the (ε_r', ε_r'') system is used
    ∇ x H = j*ω*D = j*ω*ε_r*E

Parameters are related using

ε_r_norm = ε_r + (σ/(j*ω))

Using both complex ε_r and conductivity σ does not make sense and is redundant

Generalize The Matrix Equations To Incorporate Loss
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
prmt_with_loss:matrix([ε_x + σ_x_E/(%i*ω) , 0,0],[0,ε_y + σ_y_E/(%i*ω) , 0], [0,0,ε_z + σ_z_E/(%i*ω)] );
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
prmb_with_loss:matrix([μ_x + σ_x_H/(%i*ω) , 0,0],[0,μ_y + σ_y_H/(%i*ω) , 0], [0,0,μ_z + σ_z_H/(%i*ω)] );
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
simp:false;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
faraday_lossy:M_curl*transpose(H) = j*ω*ε_0 * prmt_with_loss*transpose(E);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ampere_lossy:M_curl*transpose(E) = j*ω*μ_0 * prmb_with_loss*transpose(H);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
simp:true;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Refraction Into Diagonally Anisotropic Materials

sin(θ_1) = sqrt(b*c) * sin(θ_2) where a,b,c are on the diagonal

   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
utep_fdtd_13_101:sin(θ_1) = sqrt(b*c)*sin(θ_2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Reflection from the incident surface of a diagonally anisotropic material
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
kill(r_TE, r_TM);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
utep_fdtd_13_102:[ r_TE = (sqrt(a) * cos(θ_1) - sqrt(b) * cos(θ_2)) / (sqrt(a) * cos(θ_1) + sqrt(b) * cos(θ_2)), r_TM=(-sqrt(a) * cos(θ_1) + sqrt(b) * cos(θ_2)) / (sqrt(a) * cos(θ_1) + sqrt(b) * cos(θ_2)) ]  ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Notes On a Single Interface

Change of impedence that causes reflections (and refraction)
Snell's Law gives only the angle of transmission
Angle of transmission & reflection does not depend on polarization (TM,TE)
Fresnel equations give the amount of light reflected and transmitted
Amount of light reflected and transmitted depends on polarization

The Uniaxial Perfectly Matched Layer (UPML)

Don't want scattered waves to reflect back into the grid or re-enter from the other side
Use ε_r_tilde = ε_r' + jε_r''
Adjust loss using imaginary part jε_r'' 
Match impedence of PML to grid (problem space) by adjusting ε_r'

Fresnel equations reveal that reflections caSeparate Faradays Law Into 3 coupled PDE'sn only be prevented at
    one frequency
    one angle of incidence
    one polarization (TE or TM)

   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
kill(r_TE, R_TM);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
utep_fdtd_13_103:r_TE = (η_2 * cos(θ_1) - η_1 * cos(θ_2)) / ( η_2 * cos(θ_1) + η_2 * cos(θ_2))   ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
rte_01:subst(0, r_TE, utep_fdtd_13_103);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
solve(rte_01, η_2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
utep_fdtd_13_104:r_TM = (η_2 * cos(θ_2) - η_1 * cos(θ_1)) / ( η_1 * cos(θ_1) + η_2 * cos(θ_2))   ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
rtm_01:subst(0, r_TM, utep_fdtd_13_104);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
solve(rtm_01, η_2 );
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
need η_1 = η_2 for all angles, polarizations, and all frequencies

Make PML anisotropic to get 0% reflection 100% transmission for all angles, frequencies, polarizatoins

Math the grid impedence to the impedence of the absorbing region perfectly

η = sqrt(μ/ε) at all locations on the incident interface of the PML 

Ensure perfectly matched impedence matching the free-space impedence (air) 

   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
0;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(μ_r,r_TE, r_TM);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
utep_fdtd_13_105:[s] = [μ_r], [s] = matrix([a,0,0],[0,b,0],[0,0,c]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Design Anisotropic Matrerial For Zero Reflection

Set sqrt(b*c) = 1 Then

sin(θ_1) = sin(θ_2) ⟶ No Refraction!

Then the reflection coefficients are no longer angle-dependent

Then the reflection coefficients reduce to 

   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
utep_fdtd_13_106:[θ_1 = θ_2,r_TE = (sqrt(a) * cos(θ_1) - sqrt(b) * cos(θ_2)) / (sqrt(a) * cos(θ_1) + sqrt(b) * cos(θ_2)), r_TM=(-sqrt(a) * cos(θ_1) + sqrt(b) * cos(θ_2)) / (sqrt(a) * cos(θ_1) + sqrt(b) * cos(θ_2)) ]  ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
an_01:subst(θ_2=θ_1, second(utep_fdtd_13_106));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
an_02:radcan(an_01);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
an_03:subst(θ_2=θ_1, third(utep_fdtd_13_106));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
an_04:radcan(an_03);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Set a = b and the reflection equations are simplified 
Reflection is always zero for any frequency, angle of incidence or polarization!

The necessary condtions for zero reflection under any conditions are:
    sqrt(b*c) = 1
    a = b

Now set an_02 and an_04 equal to zero
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
an_05: subst(a,b, an_02);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
an_06: subst(a,b, an_04);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
an_07:sqrt(b*c) = 1;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
an_08:radcan(an_07)/sqrt(c);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
an_09:(an_08^2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Now write the PML in terms of one parameter s_z
This is a wave travelling in the +z direction hitting one interface
s_z has 2 components, real for impedence, imaginary to cause loss
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
s_z: α-%i*β;sz:matrix([s_z,0,0],[0,s_z,0],[0,0,1/s_z]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Require PML along all borders. This requires 2 other tensors for the x and y directions
Multiply 3 directional matrices to get the full matrix for the UPML
PML Regions will overlap in the corners
Sx, Sy, Sz are 1 in the problem space, ≠ 1 in the PML
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
kill(s_z);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sx:matrix([1/s_x,0,0],[0,s_x,0],[0,0,s_x]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sy:matrix([s_y,0,0],[0,1/s_y,0],[0,0,s_y]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sz:matrix([s_z,0,0],[0,s_z,0],[0,0,1/s_z]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
s:sx*sy*sz;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Maxwell's Equations Modified For UPML
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
ε_r:matrix([ε, 0,0],[0,ε,0],[0,0,ε]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
μ_r:matrix([μ, 0,0],[0,μ,0],[0,0,μ]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
express(curl(E)) = k_0 * μ_r * s*H;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
express(curl(H)) = k_0 * ε_r * s*E;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Move s over to multiply the curl operation by the reciprocal of s
Use the curl operator matrix in place of the curl operator itself
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
sr:matrix([1/row(s,1)[1][1],0,0],[0,1/row(s,2)[1][2], 0],[0,0,1/row(s,3)[1][3]]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Here Dx, Dy, Dz stand for ∂/∂x,∂/∂y,∂/∂z because maxima doesn't
handle currying of the diff operator/function
Note use of dot operator instead of * for standard multiplication
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
cop: sr . M_curl;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
The factors s_x, s_y, s_z are stretching the coordinates into complex space
Inside the z PML s_x = s_y = 1 except at the extreme corners with overlap
Inside the y PML s_x = s_z = 1 except at the extreme corners with overlap
Inside the x PML s_z = s_y = 1 except at the extreme corners with overlap

The UPML and SC-PML have nearly identical performance w.r.t all parameters

Calculating the PML Parameters
Introduce fictitious conductivity to assist in modelling the loss
Inside the grid         σ_x, σ_y, σ_z = 0 (no loss)
Outside the grid      σ_x ≠ 0, σ_y ≠ 0, σ_z ≠ 0
Grading fictitious conductivity from zero at boundary increasing outward

Borrow method of incorporting loss into complex permittivity using conductivity

L_x is width of PML in x direction, x is position within pml
x/L_x ratio will go from zero to 1 as x ⟶ boundary to outer edge of  PML
Raising to power of 3 gives a curvature to the ratio over L_x
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
σ_x(x):=ε_0/(2*dt) *(x/L_x)^3; s_x(x):=1 + σ_x(x) / (%i* ω*ε_0);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
σ_y(y):=ε_0/(2*dt) *(y/L_y)^3; s_y(y):=1 + σ_y(y) / (%i* ω*ε_0);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
σ_z(z):=ε_0/(2*dt) *(z/L_z)^3; s_z(z):=1 + σ_z(z) / (%i* ω*ε_0);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Build σ_x and σ_y arrays with tapered loss increasing at the inner edge of the PML

nx = 1,2,3, ...
ny = 1,2,3, ...
nz = 1,2,3,...

Within PML 
    0 < nx/NXLO ≤ 1
    0 < ny/NYLO ≤ 1
    0 < nz/NZLO ≤ 1

x / L_x ≅ nx / NXLO = nx / NXHI
y / L_y ≅ ny / NYLO = ny / NYXHI
z / L_z ≅ nz / NZLO = nz / NZHI

NXLO is width of PML on x-low side
NXHI is width of PML on x-high side
NYLO is width of PML on y-low side
NYHI is width of PML on y-high side
NZLO is width of PML on z-low side
NZHI is width of PML on z-high side

Maxwell's Equations In The Frequency Domain Without PML

∇ x E(ω) = -jωμ_0[μ_r]H(ω)
∇ x H(ω) = σE(ω) + jωD(ω) where D(ω) = ε_0[ε_r]E(ω)

Incorporate the PML independently of actual materials modelled using  frequency-domain Maxwell's Equations

∇ x E(ω) = -jωμ_0[μ_r][s]H(ω)
∇ x H(ω) = σE(ω) + jω[s]D(ω) where D(ω) = ε_0[ε_r]E(ω)
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
E_n: sqrt(ε_0/μ_0)*E; D_n:1/sqrt(μ_0*ε_0) * E; c_0 = 1/sqrt(μ_0*ε_0);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Maxwell's Equations with PML and Normalized Fields

∇ x E_n(ω) = -jω * ([μ_r]/c_0)*[s] * H(ω)
∇ x H(ω) = η_0 * σ* g*E_n(ω) + (jω/c_0) *[s]  * D_n(ω)
D_n(ω) = [ε_r] * E_n(ω)
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
En(ω):=[En_x(ω), En_y(ω), En_z(ω) ];H(ω):=[H_x(ω), H_y(ω), H_z(ω) ];Dn(ω):=[Dn_x(ω), Dn_y(ω), Dn_z(ω) ];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
M_curl;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
μ_r:matrix([μ_xx, μ_xy, μ_xz],[μ_yx, μ_yy, μ_yz], [μ_zx, μ_zy, μ_zz]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ε_r:matrix([ε_xx, ε_xy, ε_xz],[ε_yx, ε_yy, ε_yz], [ε_zx, ε_zy, ε_zz]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
σ:matrix([σ_xx, σ_xy, σ_xz],[σ_yx, σ_yy, σ_yz], [σ_zx, σ_zy, σ_zz]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
s;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
simp:false;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
faraday_with_pml:M_curl * transpose(En(ω)) = -%i*ω*(1/c_0) * μ_r * s * transpose(H(ω));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ampere_with_pml:M_curl * H(ω) = η_0 * σ * transpose(En(ω)) + (((%i*ω)/c_0) * s * transpose(Dn(ω)));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_with_pml:transpose(Dn(ω)) = ε_r * transpose(En(ω));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Assume Only Diagonal Tensors
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
ε_r_diag:matrix([ε_xx, 0,0],[0,ε_yy,0],[0,0,ε_zz]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
μ_r_diag:matrix([u_xx, 0,0],[0,u_yy,0],[0,0,u_zz]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
σ_diag:matrix([σ_xx, 0,0],[0,σ_yy,0],[0,0,σ_zz]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_diag_pml:M_curl * transpose(En(ω)) = -%i*ω*(1/c_0) * μ_r_diag * s * transpose(H(ω));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_diag_pml:M_curl * H(ω) = η_0 * σ_diag * transpose(En(ω)) + (((%i*ω)/c_0) * s * transpose(Dn(ω)));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_diag_pml:transpose(Dn(ω)) = ε_r_diag * transpose(En(ω));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
simp:true;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
dfdp_01:M_curl . transpose(En(ω)) = (-%i*ω)*(1/c_0) . μ_r_diag . s .  transpose(H(ω));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_pml_almost:psubst(
        [Dy*En_z(ω)='diff(En_z(ω), y), 
        Dz*En_y(ω)='diff(En_y(ω),z) ,
        Dz*En_x(ω)='diff(En_x(ω),z) ,
        Dz*En_y(ω)='diff(En_y(ω),z)  ,       
        Dx*En_y(ω)='diff(En_y(ω),x)    ,
        Dy*En_x(ω)='diff(En_x(ω),y),
        Dx*En_z(ω)='diff(En_z(ω),x)
    ] ,dfdp_01);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Separate Faradays Law Into 3 coupled PDE's
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
far_pml_x:row(lhs(far_pml_almost),1)[1][1] = %i*ω*(1/c_0) * row(part(part(part(rhs(far_pml_almost),1),2),2),1)[1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_pml_y:row(lhs(far_pml_almost),2)[1][1] = %i*ω*(1/c_0) * row(part(part(part(rhs(far_pml_almost),1),2),2),2)[1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_pml_z:row(lhs(far_pml_almost),3)[1][1] = %i*ω*(1/c_0) * row(part(part(part(rhs(far_pml_almost),1),2),2),3)[1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Separate Ampere's Law Into 3 coupled PDE's
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
dapn_01:M_curl . H(ω) = η_0 . σ_diag . transpose(En(ω)) + (((%i*ω)/c_0) . s . transpose(Dn(ω)));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
apx_01:row(lhs(dapn_01),1)[1][1] = %i*ω*(1/c_0)  . row(part(part(part(rhs(dapn_01),1),2),2),1)[1][1] + η_0*part(part(part(rhs(dapn_01),2),2),1)[1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_pml_x:psubst( 
    [Dy*H_z(ω)='diff(H_z(ω),y) ,
    Dz*H_y(ω)='diff(H_y(ω),z)], apx_01);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
apy_01:row(lhs(dapn_01),2)[1][1] = %i*ω*(1/c_0)  . row(part(part(part(rhs(dapn_01),1),2),2),2)[1][1] + η_0*part(part(part(rhs(dapn_01),2),2),2)[1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_pml_y:psubst( 
    [Dz*H_x(ω)='diff(H_x(ω),z) ,
    Dx*H_z(ω)='diff(H_z(ω),x)], apy_01);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
apz_01:row(lhs(dapn_01),3)[1][1] = %i*ω*(1/c_0)  . row(part(part(part(rhs(dapn_01),1),2),2),3)[1][1] + η_0*part(part(part(rhs(dapn_01),2),2),3)[1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_pml_z:psubst( 
    [Dx*H_y(ω)='diff(H_y(ω),x) ,
    Dy*H_x(ω)='diff(H_x(ω),y)], apz_01);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Separate The Constitutive Relations Into 3 Equations
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
crpn_01:transpose(Dn(ω)) = ε_r_diag . transpose(En(ω));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_x:row(lhs(crpn_01),1)[1][1] = row(rhs(crpn_01),1)[1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_y:row(lhs(crpn_01),2)[1][1] = row(rhs(crpn_01),2)[1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_z:row(lhs(crpn_01),3)[1][1] = row(rhs(crpn_01),3)[1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Substitute Expressions for s_x, s_y, s_z Into The Curl Equations
Will take some work to get maxima to look like the slides

They are correct mathematically but I will create equations
that look like the slide formats below until I can simplify these properly
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
amp_s_x:psubst([s_x=s_x(x), s_y=s_y(y), s_z=s_z(z)], amp_pml_x);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_s_y:psubst([s_x=s_x(x), s_y=s_y(y), s_z=s_z(z)], amp_pml_y);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_s_z:psubst([s_x=s_x(x), s_y=s_y(y), s_z=s_z(z)], amp_pml_z);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_s_x:subst([s_x=s_x(x), s_y=s_y(y), s_z=s_z(z)], far_pml_x);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_s_y:subst([s_x=s_x(x), s_y=s_y(y), s_z=s_z(z)], far_pml_y);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_s_z:subst([s_x=s_x(x), s_y=s_y(y), s_z=s_z(z)], far_pml_z);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Equations with s_x, s_y, and s_z Expressions Substituted For Variables
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
utep_fdtd_13_200:[ σ_x=(x^3*ε_0)/(2*L_x^3*dt),  σ_y = (y^3*ε_0)/(2*L_y^3*dt), σ_z=(z^3*ε_0)/(2*L_z^3*dt),s_x = 1 + (σ_x/(%i*ω*ε_0)) , s_y = 1 + (σ_y/(%i*ω*ε_0)), s_z=1 + (σ_z/(%i*ω*ε_0)) ];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Turning off simplfication to get the desired presentation format
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
simp:false;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Maxwell's Equations In  Frequency Domain  With PML
Manual Entry To Match The Slides For Pedagogical Purposes
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
far_x_sub: %i*ω * radcan(1/rhs(utep_fdtd_13_200[1]))  .  rhs(utep_fdtd_13_200[2]) . rhs(utep_fdtd_13_200[1]) * transpose(H(ω))  = -(c_0/μ_xx) *( 'diff(En_z(ω),y) - 'diff(En_y(ω), z) ) ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_y_sub: %i*ω * rhs(utep_fdtd_13_200[1])  . radcan(1/rhs(utep_fdtd_13_200[2])) . rhs(utep_fdtd_13_200[1]) * transpose(H(ω))  = -(c_0/μ_xx) *( 'diff(En_x(ω),z) - 'diff(En_z(ω), x) )  ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_y_sub: %i*ω * rhs(utep_fdtd_13_200[1])  * rhs(utep_fdtd_13_200[2]) * radcan(1/rhs(utep_fdtd_13_200[1])) * transpose(H(ω))  = -(c_0/μ_xx) *( 'diff(En_y(ω),x) - 'diff(En_x(ω),y) )  ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_x_sub:%i*ω * radcan(1/rhs(utep_fdtd_13_200[1]))  .  rhs(utep_fdtd_13_200[2]) . rhs(utep_fdtd_13_200[1]) * transpose(Dn(ω))  =  c_0 *( 'diff(H_y(ω),x) - 'diff(H_x(ω), y) )  - (σ_xx/ε_0) * En_x(ω) ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_y_sub:%i*ω * rhs(utep_fdtd_13_200[1])  . radcan(1/rhs(utep_fdtd_13_200[2])) . rhs(utep_fdtd_13_200[1]) * transpose(Dn(ω))  =  c_0 *( 'diff(H_x(ω),z) - 'diff(H_z(ω), x) )  - (σ_yy/ε_0) * En_y(ω) ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_y_sub:%i*ω * rhs(utep_fdtd_13_200[1])  . rhs(utep_fdtd_13_200[2]) .radcan(1/ rhs(utep_fdtd_13_200[1])) * transpose(Dn(ω))  =  c_0 *( 'diff(H_y(ω),x) - 'diff(H_x(ω), y) )  - (σ_zz/ε_0) * En_z(ω) ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_diag_pml;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_diag_pml_x:row(lhs(crel_diag_pml),1)[1][1]  = part(row(part(rhs(crel_diag_pml),1),1),1)[1] * row(part(rhs(crel_diag_pml),2),1)[1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_diag_pml_x:row(lhs(crel_diag_pml),2)[1][1]  = part(row(part(rhs(crel_diag_pml),1),2),1)[2] * row(part(rhs(crel_diag_pml),2),2)[1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_diag_pml_x:row(lhs(crel_diag_pml),3)[1][1]  = part(row(part(rhs(crel_diag_pml),1),3),1)[3] * row(part(rhs(crel_diag_pml),2),3)[1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
WARNING! PML DOES NOT HANDLE NUMERICAL BOUNDARY CONDITIONS!!!

Lecture 14 Starts Here

1. Conversion Of Equations From Frequency To Time Domain
2. Numerical Approximations 
3. Derivation Of Update Equations
4. Summary Of All Update Equations
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
Conversion To Time Domain

Assume No Loss Due To Devices - Only In PML

Inverse Fourier Transform Required

Common Fourier Transforms

F{g(t)} = G(ω)
F{a*g(t)} = a*G(ω)
        a
    d
F{----- g(t) } = (j*ω)^a * G(ω)
     a  
  dt
     t                      1
F{∫ (g(τ) dτ } = ----- * G(ω)
   -∞                    j*ω

NOTE: simp is currently false

   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
s01:[s_x=1 + σ_x/(%i*ω*ε_0),s_y=1 + σ_y/(%i*ω*ε_0)  , s_z=1 + σ_z/(%i*ω*ε_0)];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
up_01:%i*ω*(1/rhs(s01[1])) * (rhs(s01[2])) * (rhs(s01[3]) )* row(transpose(H(ω)) ,1)[1][1] = (c_0/μ_xx) *second(rhs(far_x_sub));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
C_x_E(ω) = second(rhs(far_x_sub)); 
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Switch To Unevaluated s_x, s_y, s_z
Move 1/s_x to the rhs of the equation
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
up_02:up_01 * rhs(s01[1]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Manually forcing the substitutions for now to get the correct presentation

   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
up_03:part(lhs(up_01),1) * part(lhs(up_01),2) * part(lhs(up_01),4) * part(lhs(up_01),5)  * part(lhs(up_01),6)  = rhs(up_01) * rhs(s01[1]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
up_04: %i*ω*H_x(ω) + ((σ_y + σ_z)/ε_0) *H_x(ω) + (1/(%i*ω)) * ((σ_y*σ_z)/ε_0^2) *H_x(ω) = -(c_0/μ_xx) * C_x_E(ω) - (1/(%i*ω)) * ((c_0*σ_x)/(ε_0*μ_xx)) * C_x_E(ω);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Inverse Fourier Transform The Frequency Domain Equations To Get Time Domain Equations
This procedure and the format of the equations are identical (except for x,y,z) in all 6 eqns

   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
up_05:subst([%i*ω*H_x(ω)='diff(H_x(t),t)], up_04);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
up_06:subst([ ((σ_y + σ_z)/ε_0) *H_x(ω)= ((σ_y + σ_z)/ε_0) *H_x(t) ] , up_05);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
up_07:subst([(1/(%i*ω)) * ((σ_y*σ_z)/ε_0^2) *H_x(ω) =integrate( ((σ_y*σ_z)/ε_0^2) *H_x(τ),τ)], up_06 );
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
up_08:subst([ -(c_0/μ_xx)*C_x_E(ω)=-(c_0/μ_xx)*C_x_E(t)], up_07 );
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
up_09:subst([(1/(%i*ω)) * ((c_0*σ_x)/(ε_0*μ_xx)) * C_x_E(ω)='integrate( ((c_0*σ_x)/(ε_0*μ_xx))*C_x_E(τ),τ) ], up_08 ) ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Use up_09 as the template for all faraday equations
Use the same procedure on ampere's law equations
Use the same procedure for the constitutive relations

Just summarizing the resulting time domain equations for now 
Will derive properly using maxima properly later
He expands C_x_E out but it is left unexpanded here, same for C_y_E,C_z_E
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
far_x_td:up_09;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_y_td:'diff(H_y(t),t)+((σ_x+σ_z)/ε_0)*H_y(t)+'integrate(((σ_x*σ_z)/ε_0^2)*H_y(τ),τ)=(-c_0/μ_yy)*C_y_E(t)-'integrate(((c_0*σ_y)/(ε_0*μ_yy))*C_y_E(τ),τ);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
far_z_td:'diff(H_z(t),t)+((σ_x+σ_y)/ε_0)*H_z(t)+'integrate(((σ_x*σ_y)/ε_0^2)*H_z(τ),τ)=(-c_0/μ_zz)*C_z_E(t)-'integrate(((c_0*σ_z)/(ε_0*μ_zz))*C_z_E(τ),τ);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Transform Ampere's Law Frequency Domain Eqns To Time Domain
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
amp_x_td:'diff(D_x(t),t)+((σ_y+σ_z)/ε_0)*D_x(t)+'integrate(((σ_y*σ_z)/ε_0^2)*D_x(τ),τ)=c_0*C_x_H(t)-'integrate(((c_0*σ_x)/ε_0)*C_x_H(τ) ,τ)
;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_y_td:'diff(D_y(t),t)+((σ_x+σ_z)/ε_0)*D_y(t)+'integrate(((σ_x*σ_z)/ε_0^2)*D_y(τ),τ)=c_0*C_y_H(t)-'integrate(((c_0*σ_y)/ε_0)*C_y_H(τ) ,τ);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
amp_z_td:'diff(D_z(t),t)+((σ_x+σ_y)/ε_0)*D_z(t)+'integrate(((σ_x*σ_y)/ε_0^2)*D_z(τ),τ)=c_0*C_z_H(t)-'integrate(((c_0*σ_z)/ε_0)*C_z_H(τ) ,τ);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Time Domain Constitutive Relations For D and E
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
crel_x_td: Dn_x(t) = ε_xx*En_x(t);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_y_td: Dn_y(t) = ε_yy*En_y(t);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
crel_y_td: Dn_y(t) = ε_yy*En_y(t);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
FDTD Numerical Approximations

Integrals       ⟶ Sums
Derivatives   ⟶ Differences

   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
fd_far_x_p1:['diff(H_x(t) ,t) , (H_x[i,j,k,t+dt/2] - H_x[i,j,k,t-dt/2]) / dt ];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Need an H_x value that exists at the integer time step - average the 2 values available
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
fd_far_x_p2:[ ((σ_y + σ_z)/ε_0) *H_x(t) , ((σ_y[i,j,k] + σ_z[i,j,k])/ε_0) *((H_x[i,j,k,t+dt/2] + H_x[i,j,k,t-dt/2] )/2)] ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
The time step in fd_far_x_p3 goes dt/2 too far or not far enough
Need to integrate up to time t, not t+dt/2 or t-dt/2
Pull one term out of the summation, sum goes only to t-dt/2
Final time step is multipled by dt/2 
Final time step must be averaged to exist at an integer time step
Upper summation limit is t-dt/2 ⟶ must update summation before updating the H field!
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
fd_far_x_p3:['integrate(((σ_y*σ_z)/ε_0^2) * H_x(τ),τ), ((σ_y*σ_z)/ε_0^2) *  'integrate(H_x(τ),τ) , ((σ_y*σ_z)/ε_0^2) * sum(H_x[i,j,k,T] *dt, T, dt/2, t+dt/2), ((σ_y*σ_z)/ε_0^2) * (H_x[i,j,k,t+dt/2] * dt/2) + sum(H_x[i,j,k,T] , T, dt/2, t-dt/2) , ((σ_y*σ_z)/ε_0^2)*( ((H_x[i,j,k,t+dt/2] + H_x[i,j,k,t-dt/2] )/2) * (dt/2) + sum(H_x[i,j,k,T] * dt, T, dt/2, t-dt/2) )  , ((σ_y*σ_z*dt)/ε_0^2)* ( ((H_x[i,j,k,t+dt/2] + H_x[i,j,k,t-dt/2] )/4)  + sum(H_x[i,j,k,T] , T, dt/2, t-dt/2) ) ];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fd_far_x_p4:[-(c_0/μ_xx) * C_x_E(t) , -(c_0/μ_xx[i,j,k]) * C_x_E[i,j,k,t] , C_x_E[i,j,k,t]=((En_z[i,j+1,k,t] - En_z[i,j,k,t]) / dy) - ((En_y[i,j,k+1,t] - E_y[i,j,k,t])/dz)];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Term 5 - C_x_E exists at the integer time step, upper limit of t is valid
End time on this summation means that we update the summation before
updating the E field
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
fd_far_x_p5:[ -'integrate(  ((c_0*σ_x)/(ε_0*μ_xx)) * C_x_E(τ) ,τ,minf,t) ,   ((c_0*σ_x)/(ε_0*μ_xx)) * 'integrate(C_x_E(τ),τ), ((c_0 * σ_x[i,j,k])/(ε_0 * μ_xx[i,j,k])) * sum(C_x_E[i,j,k,T]*dt, T,0,t)  , ((c_0*σ_x)/(ε_0*μ_xx)) * 'integrate(C_x_E(τ),τ), ((c_0 * dt*σ_x[i,j,k])/(ε_0 * μ_xx[i,j,k])) * sum(C_x_E[i,j,k,T], T,0,t) ]  ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fd_far_x: fd_far_x_p1[2] + fd_far_x_p2[2] + fd_far_x_p3[2] = fd_far_x_p4[2] +  fd_far_x_p5[5];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Build the other 5 equations by inspection and parameter and index substitution
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
fd_far_y:(H_y[i,j,k,t+dt/2]-H_y[i,j,k,t-dt/2])/dt +
    ((σ_x[i,j,k]+σ_z[i,j,k])/ε_0)*((H_y[i,j,k,t+dt/2]+H_y[i,j,k,t-dt/2])/2)  +
    ((σ_x*σ_z)/ε_0^2)*'integrate(H_y(τ),τ)   
= (-c_0/μ_yy[i,j,k])*C_y_E[i,j,k,t]+
    ((c_0*dt*σ_y[i,j,k])/(ε_0*μ_yy[i,j,k])) *'sum(C_y_E[i,j,k,T],T,0,t);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fd_far_z:(H_z[i,j,k,t+dt/2]-H_z[i,j,k,t-dt/2])/dt +
    ((σ_y[i,j,k]+σ_x[i,j,k])/ε_0)*((H_z[i,j,k,t+dt/2]+H_z[i,j,k,t-dt/2])/2)  +
    ((σ_y*σ_x)/ε_0^2)*'integrate(H_z(τ),τ)   
= (-c_0/μ_zzy[i,j,k])*C_z_E[i,j,k,t]+
    ((c_0*dt*σ_z[i,j,k])/(ε_0*μ_zz[i,j,k])) *'sum(C_z_E[i,j,k,T],T,0,t);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fd_amp_x:(Dn_x[i,j,k,t+dt]-Dn_z[i,j,k,t])/dt +
    ((σ_y[i,j,k]+σ_x[i,j,k])/ε_0)*((H_z[i,j,k,t+dt/2]+H_z[i,j,k,t-dt/2])/2)  +
    ((σ_y*σ_x)/ε_0^2)*'integrate(H_z(τ),τ)   
= (-c_0/μ_zzy[i,j,k])*C_z_E[i,j,k,t]+
    ((c_0*dt*σ_z[i,j,k])/(ε_0*μ_zz[i,j,k])) *'sum(C_z_E[i,j,k,T],T,0,t);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Derive The Update Equations
Maxima does a lot of work for us here:
    Expand the equation by multiplying all terms out.
    Collect Common Terms
    Solve for H_x at the t+dt/2 time step

    
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
solve(fd_far_x, H_x[i,j,k,t+dt/2]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Compact Form of the Update Equation

Use variables to hold larger expressions to declutter the math and the code
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */

/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Final Form Of The Update Equations

Update coefficients are computed before the main  FDTD loop
The integration terms are computed inside the main loop before the update equation
The update equation is computed inside the main FDTD loop immediately after 
the integration terms are updated

   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
mhx0:m_Hx0[i,j,k] = (1/dt) + ( (σ_y_H[i,j,k] + σ_z_H[i,j,k] ) /(2*ε_0)) + ((σ_y_H[i,j,k]  * σ_z_H[i,j,k] * dt) / (4*ε_0^2));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
mhx1:m_Hx1[i,j,k] = (1/ mHx0[i,j,k]) * ( (1/dt) - (( σ_y_H[i,j,k] + σ_z_H[i,j,k] ) / (2*ε_0)) - ((σ_y_H[i,j,k] * σ_z_H[i,j,k] * dt )  / (4*ε_0^2)));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
mhx2:m_Hx2[i,j,k] = -(1/m_Hx0[i,j,k]) * (c_0/μ_xx[i,j,k]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
mhx3:m_Hx3[i,j,k] = -(1/m_Hx0) * ((c_0 * dt * σ_x_H[i,j,k] )/ (ε_0*μ_xx[i,j,k]) )  ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
mhx4:m_Hx4 = -(1/m_Hx0[i,j,k]) * (dt/ε_0^2)  * σ_y_H[i,j,k] * σ_z_H[i,j,k] ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
icex: I_CEx[i,j,k,t] = sum(C_x_E[i,j,k,T], T,0,t);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ihx:I_Hx[i,j,k,t-dt/2] = sum( H_x[i,j,k,T],T,dt/2,t-dt/2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cex:C_x_E[i,j,k,t] = ((En_z[i,j+1,k,t]  - En_z[i,j,k,t]) /dy ) -  ((En_y[i,j+1,k,t]  - En_y[i,j,k,t]) / dz ) ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
uphxcom:H_x[i,j,k,t+dt/2]  =m_Hx1[i,j,k] * H_x[i,j,k,t-dt/2]  + m_Hx2[i,j,k] * C_x_E[i,j,k,t] + m_Hx3[i,j,k]  * I_CEx[i,j,k,t] + m_Hx4[i,j,k]*I_Hx[i,j,k,t];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
To get the full equation substitute the rhs of the above expressions back into uphxcom
e.g. subst(m_Hx1[i,j,k]=rhs(mhx1)], uphxcom)
The placeholder variable names can be simplifed 
There are ways to make maxima perform the substitutions more automatically if desired
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
 subst([m_Hx1[i,j,k]=rhs(mhx1)], uphxcom);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Testing The FDTD Equations With PML 
Set all PML parameters (conductivity) to zero
Equations should reduce to the the update equations without PML from lectures 11,12,13
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
m_Hx1_No_Pml:1; m_Hx2_No_Pml:-((c_0*dt)/μ_xx[i,j,k]);m_Hx3_No_Pml:0 ; m_Hx4_No_Pml:0;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
up_hx_cor_01:psubst([m_Hx1[i,j,k]=m_Hx1_No_Pml, m_Hx2[i,j,k]=m_Hx2_No_Pml, m_Hx3[i,j,k] =m_Hx3_No_Pml, m_Hx4[i,j,k]=m_Hx4_No_Pml ] , uphxcom);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
up_hx_cor_02:subst([C_x_E[i,j,k,t]=rhs(cex)] , up_hx_cor_01);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
up_hx_cor_03:radcan(subst( ((En_y[i,j+1,k,t]  - En_y[i,j,k,t]) / dz)=0, up_hx_cor_02));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
This is mathematically correct but...
TODO: Need to get this separated into 2 fractions again
TODO: Update Equation Derivation For Hy, Hz, Dx, Dy, Dz,ex,Ey,Ez
   [wxMaxima: comment end   ] */



